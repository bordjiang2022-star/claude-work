# 客户体验包方案 - 代理服务器架构

## 方案概述

**核心思想：** 将API密钥保留在您控制的服务器上，客户的Docker容器通过代理访问服务。

## 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                     客户端 Docker 容器                           │
│  ┌──────────────┐                    ┌──────────────────────┐  │
│  │   前端       │                    │  轻量后端（代理）     │  │
│  │  React UI    │◄──────HTTP────────►│  - 转发请求          │  │
│  │  Port 3000   │                    │  - 本地音频处理       │  │
│  └──────────────┘                    │  - WebSocket桥接     │  │
│                                      └──────┬───────────────┘  │
└─────────────────────────────────────────────┼──────────────────┘
                                              │
                                      HTTPS (加密通信)
                                              │
┌─────────────────────────────────────────────▼──────────────────┐
│                您的云服务器 (您控制的环境)                       │
│  ┌────────────────────────────────────────────────────────┐    │
│  │               中心化后端服务                            │    │
│  │  ┌──────────────┐  ┌─────────────┐  ┌──────────────┐  │    │
│  │  │License验证   │  │配额管理      │  │API密钥管理   │  │    │
│  │  │- 试用期检查  │  │- 调用次数    │  │- 安全存储    │  │    │
│  │  │- 设备指纹    │  │- 使用时长    │  │- 动态轮换    │  │    │
│  │  │- IP白名单    │  │- 并发限制    │  │- 多租户隔离  │  │    │
│  │  └──────────────┘  └─────────────┘  └──────────────┘  │    │
│  │                                                         │    │
│  │  ┌──────────────────────────────────────────────────┐  │    │
│  │  │          翻译服务引擎                             │  │    │
│  │  │  - 调用阿里云DashScope API (使用您的密钥)        │  │    │
│  │  │  - 管理WebSocket连接池                           │  │    │
│  │  │  - 缓存优化                                       │  │    │
│  │  └──────────────────┬───────────────────────────────┘  │    │
│  └─────────────────────┼──────────────────────────────────┘    │
└────────────────────────┼─────────────────────────────────────┘
                         │
                         │ WSS + API密钥
                         ▼
            ┌────────────────────────┐
            │  阿里云 DashScope API  │
            │  (您的账号和密钥)       │
            └────────────────────────┘
```

## 实施方案

### 阶段1: 服务拆分

#### 1.1 客户端容器（无密钥版本）

**文件结构：**
```
customer-docker/
├── frontend/              # 完整的React前端
├── backend-lite/          # 轻量后端（仅代理）
│   ├── main.py           # FastAPI代理服务器
│   ├── proxy_client.py   # 连接到您的中心服务器
│   └── audio_handler.py  # 本地音频处理
├── docker-compose.yml    # 容器编排
└── .env.example          # 配置示例（无密钥）
```

**backend-lite/main.py** (客户端轻量后端):
```python
"""
客户端代理后端 - 不包含API密钥
所有翻译请求转发到中心服务器
"""
from fastapi import FastAPI, WebSocket, Depends
from fastapi.middleware.cors import CORSMiddleware
import httpx
import os

app = FastAPI(title="Live Translate Client Proxy")

# 中心服务器配置
CENTRAL_SERVER_URL = os.getenv(
    "CENTRAL_SERVER_URL",
    "https://api.yourdomain.com"  # 您的服务器地址
)
LICENSE_KEY = os.getenv("LICENSE_KEY", "")  # 客户的license key

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ProxyClient:
    """代理客户端 - 转发请求到中心服务器"""

    def __init__(self, license_key: str):
        self.license_key = license_key
        self.client = httpx.AsyncClient(
            base_url=CENTRAL_SERVER_URL,
            headers={"X-License-Key": license_key},
            timeout=30.0
        )

    async def start_translation(self, config: dict):
        """转发翻译启动请求"""
        response = await self.client.post(
            "/api/proxy/translation/start",
            json=config
        )
        return response.json()

    async def stop_translation(self):
        """转发翻译停止请求"""
        response = await self.client.post(
            "/api/proxy/translation/stop"
        )
        return response.json()

@app.post("/api/translation/start")
async def start_translation(config: TranslationConfig):
    """启动翻译 - 通过代理"""
    proxy = ProxyClient(LICENSE_KEY)
    result = await proxy.start_translation(config.dict())
    return result

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket桥接 - 连接到中心服务器"""
    await websocket.accept()

    # 建立到中心服务器的WebSocket连接
    import websockets
    async with websockets.connect(
        f"{CENTRAL_SERVER_URL.replace('https', 'wss')}/ws/proxy",
        extra_headers=[("X-License-Key", LICENSE_KEY)]
    ) as central_ws:
        # 双向转发消息
        async def forward_to_central():
            async for message in websocket.iter_text():
                await central_ws.send(message)

        async def forward_to_client():
            async for message in central_ws:
                await websocket.send_text(message)

        # 并发运行两个转发任务
        import asyncio
        await asyncio.gather(
            forward_to_central(),
            forward_to_client()
        )
```

#### 1.2 中心服务器（您控制）

**文件结构：**
```
central-server/
├── main.py                    # 主服务器
├── license_manager.py         # License管理
├── quota_manager.py           # 配额管理
├── translation_proxy.py       # 翻译代理服务
├── requirements.txt
└── .env                       # 包含DASHSCOPE_API_KEY
```

**central-server/license_manager.py**:
```python
"""
License管理系统
"""
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime, timedelta
import secrets

Base = declarative_base()

class License(Base):
    __tablename__ = "licenses"

    id = Column(Integer, primary_key=True)
    license_key = Column(String(64), unique=True, index=True)
    customer_name = Column(String(200))
    customer_email = Column(String(200))

    # 试用控制
    trial_type = Column(String(20))  # 'time' 或 'quota'
    trial_days = Column(Integer, default=7)
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime)

    # 配额限制
    max_minutes = Column(Integer, default=60)  # 最多60分钟
    used_minutes = Column(Integer, default=0)
    max_sessions = Column(Integer, default=10)
    used_sessions = Column(Integer, default=0)

    # 并发控制
    max_concurrent = Column(Integer, default=1)

    # 状态
    is_active = Column(Boolean, default=True)
    last_used = Column(DateTime)

    # 设备绑定（可选）
    device_fingerprint = Column(String(100))
    ip_whitelist = Column(String(500))  # 逗号分隔的IP

class LicenseManager:
    """License管理器"""

    @staticmethod
    def generate_trial_license(
        customer_name: str,
        customer_email: str,
        trial_days: int = 7,
        max_minutes: int = 60
    ) -> str:
        """生成试用License"""
        license_key = f"TRIAL-{secrets.token_urlsafe(32)}"
        expires_at = datetime.utcnow() + timedelta(days=trial_days)

        license = License(
            license_key=license_key,
            customer_name=customer_name,
            customer_email=customer_email,
            trial_type="time",
            trial_days=trial_days,
            expires_at=expires_at,
            max_minutes=max_minutes,
            max_sessions=10,
            max_concurrent=1
        )

        # 保存到数据库
        db.add(license)
        db.commit()

        return license_key

    @staticmethod
    async def validate_license(license_key: str) -> tuple[bool, str]:
        """验证License"""
        license = db.query(License).filter_by(
            license_key=license_key
        ).first()

        if not license:
            return False, "无效的License Key"

        if not license.is_active:
            return False, "License已被禁用"

        # 检查过期
        if license.expires_at and datetime.utcnow() > license.expires_at:
            return False, f"试用已过期 (到期日期: {license.expires_at})"

        # 检查配额
        if license.used_minutes >= license.max_minutes:
            return False, f"试用时长已用完 ({license.used_minutes}/{license.max_minutes}分钟)"

        if license.used_sessions >= license.max_sessions:
            return False, f"试用次数已用完 ({license.used_sessions}/{license.max_sessions}次)"

        # 更新最后使用时间
        license.last_used = datetime.utcnow()
        db.commit()

        return True, "验证通过"

    @staticmethod
    async def get_remaining_quota(license_key: str) -> dict:
        """获取剩余配额"""
        license = db.query(License).filter_by(
            license_key=license_key
        ).first()

        if not license:
            return None

        days_remaining = (license.expires_at - datetime.utcnow()).days \
            if license.expires_at else None

        return {
            "trial_days_remaining": days_remaining,
            "minutes_remaining": license.max_minutes - license.used_minutes,
            "sessions_remaining": license.max_sessions - license.used_sessions,
            "expires_at": license.expires_at.isoformat() if license.expires_at else None
        }
```

**central-server/quota_manager.py**:
```python
"""
配额管理系统
"""
from datetime import datetime
import asyncio

class QuotaManager:
    """配额管理器"""

    def __init__(self):
        self.active_sessions = {}  # license_key -> session_info

    async def start_session(self, license_key: str) -> tuple[bool, str]:
        """启动会话 - 检查并发限制"""
        license = db.query(License).filter_by(
            license_key=license_key
        ).first()

        # 检查并发数
        current_concurrent = sum(
            1 for k, v in self.active_sessions.items()
            if k == license_key and v['active']
        )

        if current_concurrent >= license.max_concurrent:
            return False, f"已达到最大并发数 ({license.max_concurrent})"

        # 记录会话
        session_id = f"{license_key}-{datetime.utcnow().timestamp()}"
        self.active_sessions[session_id] = {
            'license_key': license_key,
            'active': True,
            'start_time': datetime.utcnow(),
            'duration': 0
        }

        return True, session_id

    async def end_session(self, session_id: str):
        """结束会话 - 更新使用量"""
        if session_id not in self.active_sessions:
            return

        session = self.active_sessions[session_id]
        session['active'] = False

        # 计算时长
        duration = (datetime.utcnow() - session['start_time']).total_seconds() / 60

        # 更新数据库
        license = db.query(License).filter_by(
            license_key=session['license_key']
        ).first()

        license.used_minutes += int(duration)
        license.used_sessions += 1
        db.commit()

    async def check_quota_during_session(self, session_id: str) -> bool:
        """会话中检查配额 - 超限自动停止"""
        if session_id not in self.active_sessions:
            return False

        session = self.active_sessions[session_id]
        license = db.query(License).filter_by(
            license_key=session['license_key']
        ).first()

        # 检查时长
        current_duration = (
            datetime.utcnow() - session['start_time']
        ).total_seconds() / 60

        total_used = license.used_minutes + current_duration

        if total_used >= license.max_minutes:
            await self.end_session(session_id)
            return False

        return True
```

**central-server/main.py**:
```python
"""
中心服务器 - 包含API密钥，提供代理服务
"""
from fastapi import FastAPI, Depends, HTTPException, Header
from license_manager import LicenseManager
from quota_manager import QuotaManager
import os

app = FastAPI(title="Live Translate Central Server")

# API密钥（安全存储）
DASHSCOPE_API_KEY = os.getenv("DASHSCOPE_API_KEY")

license_manager = LicenseManager()
quota_manager = QuotaManager()

async def verify_license(x_license_key: str = Header(...)):
    """License验证依赖"""
    valid, message = await license_manager.validate_license(x_license_key)
    if not valid:
        raise HTTPException(status_code=403, detail=message)
    return x_license_key

@app.post("/api/proxy/translation/start")
async def proxy_start_translation(
    config: dict,
    license_key: str = Depends(verify_license)
):
    """代理翻译启动请求"""

    # 检查并发和配额
    can_start, session_id_or_error = await quota_manager.start_session(
        license_key
    )

    if not can_start:
        raise HTTPException(status_code=429, detail=session_id_or_error)

    # 使用您的API密钥启动翻译
    from translation_service import TranslationService

    service = TranslationService()
    success = await service.start_translation(
        session_id=session_id_or_error,
        api_key=DASHSCOPE_API_KEY,  # 使用您的密钥
        **config
    )

    if not success:
        await quota_manager.end_session(session_id_or_error)
        raise HTTPException(status_code=500, detail="翻译启动失败")

    return {
        "success": True,
        "session_id": session_id_or_error,
        "quota": await license_manager.get_remaining_quota(license_key)
    }

@app.get("/api/license/quota")
async def get_quota(license_key: str = Depends(verify_license)):
    """查询剩余配额"""
    quota = await license_manager.get_remaining_quota(license_key)
    return quota

@app.post("/api/admin/license/create")
async def create_trial_license(
    customer_name: str,
    customer_email: str,
    trial_days: int = 7,
    max_minutes: int = 60,
    admin_key: str = Header(...)
):
    """管理员创建试用License"""
    if admin_key != os.getenv("ADMIN_KEY"):
        raise HTTPException(status_code=403, detail="无权限")

    license_key = license_manager.generate_trial_license(
        customer_name=customer_name,
        customer_email=customer_email,
        trial_days=trial_days,
        max_minutes=max_minutes
    )

    return {
        "license_key": license_key,
        "expires_in_days": trial_days,
        "max_minutes": max_minutes
    }
```

### 阶段2: Docker打包

#### 2.1 客户端Docker配置

**customer-docker/docker-compose.yml**:
```yaml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:8000
    depends_on:
      - backend-lite

  backend-lite:
    build: ./backend-lite
    ports:
      - "8000:8000"
    environment:
      # 客户需要配置的唯一参数
      - LICENSE_KEY=${LICENSE_KEY}
      - CENTRAL_SERVER_URL=${CENTRAL_SERVER_URL:-https://api.yourdomain.com}
    volumes:
      # 本地音频设备访问
      - /dev/snd:/dev/snd
    devices:
      - /dev/snd
```

**customer-docker/.env.example**:
```bash
# 客户配置文件 - 无需API密钥

# 您提供给客户的License Key
LICENSE_KEY=TRIAL-xxxxx-xxxxx-xxxxx

# 中心服务器地址（默认已设置）
CENTRAL_SERVER_URL=https://api.yourdomain.com
```

#### 2.2 中心服务器部署

**部署到您的云服务器** (例如: AWS, 阿里云, Vultr):
```bash
# 使用Docker Compose
docker-compose -f central-server/docker-compose.yml up -d

# 或使用Kubernetes
kubectl apply -f central-server/k8s/
```

### 阶段3: 客户交付流程

#### 3.1 生成试用License

```bash
# 使用管理API生成
curl -X POST https://api.yourdomain.com/api/admin/license/create \
  -H "admin-key: your-admin-secret" \
  -H "Content-Type: application/json" \
  -d '{
    "customer_name": "客户公司名称",
    "customer_email": "customer@example.com",
    "trial_days": 7,
    "max_minutes": 60
  }'

# 响应
{
  "license_key": "TRIAL-AbCdEfGh123456789",
  "expires_in_days": 7,
  "max_minutes": 60
}
```

#### 3.2 交付给客户

**发送给客户的包:**
```
customer-package/
├── docker-compose.yml
├── .env.example
├── README.md              # 使用说明
├── start.sh              # Linux/Mac启动脚本
├── start.bat             # Windows启动脚本
└── images/               # Docker镜像tar包（可选）
    ├── frontend.tar
    └── backend-lite.tar
```

**README.md** (客户说明):
```markdown
# Live Translate 试用版

## 快速开始

### 1. 配置License Key

复制 `.env.example` 为 `.env`:
```bash
cp .env.example .env
```

编辑 `.env` 文件，填入我们提供的License Key:
```
LICENSE_KEY=TRIAL-您的试用密钥
```

### 2. 启动服务

**Linux/Mac:**
```bash
chmod +x start.sh
./start.sh
```

**Windows:**
```cmd
start.bat
```

### 3. 访问应用

打开浏览器访问: http://localhost:3000

## 试用限制

- 试用期: 7天
- 使用时长: 60分钟
- 会话次数: 10次
- 并发连接: 1个

查询剩余配额:
```bash
curl http://localhost:8000/api/license/quota
```

## 技术支持

- 邮箱: support@yourdomain.com
- 文档: https://docs.yourdomain.com
```

## 优势分析

### ✅ 安全性
- **API密钥完全隔离**: 客户无法获取您的DASHSCOPE_API_KEY
- **License控制**: 可随时远程禁用试用账号
- **配额管理**: 精确控制使用量，防止滥用

### ✅ 成本控制
- **实时监控**: 追踪每个客户的API调用量
- **自动限流**: 超出配额自动停止服务
- **预算保护**: 设置每个License的最大费用

### ✅ 商业灵活性
- **试用转正**: 无缝升级到付费版本
- **多种套餐**:
  - 基础试用: 7天/60分钟
  - 标准试用: 14天/180分钟
  - 企业试用: 30天/自定义
- **数据洞察**: 了解客户使用习惯

### ✅ 用户体验
- **简单部署**: 客户只需配置一个License Key
- **本地运行**: 前端在客户本地，低延迟
- **透明配额**: 客户可查看剩余额度

## 技术要求

### 您的服务器需求
- **配置**: 2核4G起步（支持10-50并发客户）
- **带宽**: 建议10Mbps+（WebSocket数据转发）
- **成本**: 约$10-20/月（Vultr/DigitalOcean）

### 客户端需求
- Docker + Docker Compose
- 2GB可用内存
- 麦克风权限

## 实施时间表

- **第1周**: 开发中心服务器和License系统
- **第2周**: 重构客户端为代理模式
- **第3周**: 测试和优化
- **第4周**: 准备交付包和文档

## 总结

这个方案能够：
1. ✅ 完全保护您的API密钥
2. ✅ 精确控制试用客户的使用量和成本
3. ✅ 提供良好的客户体验（本地部署感）
4. ✅ 灵活的商业模式（试用→付费转化）
5. ✅ 可扩展到数百个试用客户
